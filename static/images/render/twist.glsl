//Autogenerated by sdfray

#ifdef GL_ES
precision highp float;
#endif

uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform float u_time;

struct Property {
    float diffuse, specular, transmit, refractive_index;
    vec3 color, emittance;
};

struct GeoInfo {
    float sdf;
    Property prop;
};

GeoInfo wrap(float sdf, Property prop) {
    return GeoInfo(sdf,prop);
}

GeoInfo wrap(GeoInfo info, Property prop) {
    return GeoInfo(info.sdf,prop);
}


float join(float a, float b) {
    return min(a,b);
}

GeoInfo join(GeoInfo a, GeoInfo b) {
    if (a.sdf < b.sdf) {
        return a;
    } else {
        return b;
    }
}
    
float cylinder(vec3 p, vec3 tx, mat3 rot, float height, float radius) {
    p = rot*(p-tx);
    float a = length(p.xz)-radius;
    float b = abs(p.y)-height/2.;
    return min(max(a,b),0.) + length(vec2(max(a,0.),max(b,0.)));
}
    
const Property var_11377718 = Property(0.1,0.9,0.0,1.0,vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0));
        
Property uniform_surf(vec3 p, vec3 d, Property surf) {
    return surf;
}
    
float box(vec3 p, vec3 tx, mat3 rot, vec3 whd) {
    p = rot*(p-tx);
    vec3 del = abs(p)-whd/2.;
    float mval = max(max(del.x,del.y),del.z);
    return length(vec3(max(del.x,0.),max(del.y,0.),max(del.z,0.)))+min(mval,0.);
}
    
const Property var_42727665 = Property(0.9,0.1,0.0,1.0,vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0));
        
float sphere(vec3 p, vec3 tx, float radius) {
    return length(p - tx) - radius;
}
    
const Property var_97688094 = Property(0.05,0.05,0.9,1.4,vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0));
        
float plane(vec3 p, vec3 anchor, vec3 norm) {
    return dot(p-anchor,norm);
}
    
const Property var_78282785 = Property(0.95,0.0,0.0,1.0,vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0));
        
const Property var_86528758 = Property(0.05,0.0,0.0,1.0,vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0));
        
Property checker_surf(vec3 p, vec3 d, vec3 a_v, vec3 b_v, float checker_size, Property a, Property b) {
    float a_c = dot(p,a_v);
    float b_c = dot(p,b_v);
    bool a_odd = mod(a_c,2.*checker_size) >= checker_size;
    bool b_odd = mod(b_c,2.*checker_size) >= checker_size;
    if (a_odd == b_odd) {
        return a;
    } else {
        return b;
    }
}

vec3 transform(vec3 p) {
    float rate = 8.*cos(u_time);
    return mat3(cos(p.y*rate),0.,-sin(p.y*rate),0.,1.,0.,sin(p.y*rate),0.,cos(p.y*rate))*p;
}

float sdf(vec3 p) {
    return join(box(transform(p),vec3(-0.,-0.2,0.0),mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.),vec3((1.4, 1.4, 1.4))),plane(p,vec3(0,-1,0),vec3(0.0,1.0,0.0)));
    //return join(join(cylinder(p,vec3(0.,-0.2,0.0),mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.),1.4*cos(u_time),0.7*cos(u_time)),join(box(p,vec3(-0.,-0.2,0.0),mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.),vec3((1.4, 1.4, 1.4)*cos(u_time+2.*3.14159/3.))),sphere(p,vec3(0.0,-0.2,0.0),0.7*cos(u_time+4.*3.14159/3.)))),plane(p,vec3(0,-1,0),vec3(0.0,1.0,0.0)));
}
const Property wat = Property(0.3,0.3,0.,0.0,vec3(1.0,1.0,1.0),vec3(0.0,0.0,0.0));
        
Property prop(vec3 p, vec3 d) {
    return join(wrap(box(transform(p),vec3(-0.,-0.2,0.0),mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.),vec3((1.4, 1.4, 1.4))),uniform_surf(transform(p),d,wat)),wrap(plane(p,vec3(0,-1,0),vec3(0.0,1.0,0.0)),checker_surf(p,d,vec3(1.0,0.0,0.0),vec3(0.0,0.0,1.0),0.25,var_78282785,var_86528758))).prop;
    //return join(join(wrap(cylinder(p,vec3(0.,-0.2,0.0),mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.),1.4*cos(u_time),0.7*cos(u_time)),uniform_surf(p,d,var_11377718)),join(wrap(box(p,vec3(0.,-0.2,0.0),mat3(1.,0.,0.,0.,1.,0.,0.,0.,1.),vec3((1.4, 1.4, 1.4)*cos(u_time+2.*3.14159/3.))),uniform_surf(p,d,var_42727665)),wrap(sphere(p,vec3(0.0,-0.2,0.0),0.7*cos(u_time+4.*3.14159/3.)),uniform_surf(p,d,var_97688094)))),wrap(plane(p,vec3(0,-1,0),vec3(0.0,1.0,0.0)),checker_surf(p,d,vec3(1.0,0.0,0.0),vec3(0.0,0.0,1.0),0.25,var_78282785,var_86528758))).prop;
}
        
const float D_ = 1e-4;
const vec3 DX = vec3(D_,0.0,0.0);
const vec3 DY = vec3(0.0,D_,0.0);
const vec3 DZ = vec3(0.0,0.0,D_);
vec3 gradient(vec3 p) {
    return vec3(sdf(p+DX)-sdf(p-DX),
                sdf(p+DY)-sdf(p-DY),
                sdf(p+DZ)-sdf(p-DZ))/(2.0*D_);
}

const float WORLD_RES = 1e-4;
const float WORLD_MAX = 1e4;
bool next_surface(inout vec3 p, inout vec3 d, out vec3 g, bool inside) {
    for (int i = 0; i < 1000; i++) {
        float v = inside ? -sdf(p) : sdf(p);
        if (v <= 0.) {
            v = WORLD_RES - v;
        } else if (v < WORLD_RES) {
            g = inside ? -gradient(p) : gradient(p);
            if (dot(g,d) < 0.0) {
                return true;
            }
        } else if (v > WORLD_MAX) {
            return false;
        }
        p += v*d*0.2;
    }
    return false;
}

bool next_surface(inout vec3 p, inout vec3 d, out vec3 g) {
    return next_surface(p,d,g,false);
}

bool next_surface(inout vec3 p, vec3 d, out vec3 g, vec3 stop_at) {
    for (int i = 0; i < 10000; i++) {
        float v = sdf(p);
        if (v <= 0.) {
            v = WORLD_RES - v;
        } else if (v < WORLD_RES) {
            g = gradient(p);
            if (dot(g,d) < 0.0) {
                return true;
            }
        } else if (v > WORLD_MAX) {
            return false;
        } else if (dot(stop_at-p,d) < 0.0) {
            return false;
        }
        p += v*d*0.2;
    }
    return false;
}

bool resolve_transmission(float n1, float n2, inout vec3 p, inout vec3 d, inout vec3 n) {
    float nratio = n1/n2;
    vec3 perp_oblique = cross(d,n);
    float internal = nratio*nratio*dot(perp_oblique,perp_oblique);
    if (internal > 1.) {
        d = reflect(d,n);
        return true;
    } else {
        d = refract(d,n,nratio);
        nratio = 1./nratio;
        for (int i = 0; i < 100; i++) {
            vec3 g;
            bool hit = next_surface(p,d,g,true);
            if (!hit) return false;
            n = normalize(g);
            perp_oblique = cross(d,n);
            internal = nratio*nratio*dot(perp_oblique,perp_oblique);
            if (internal > 1.) {
                d = reflect(d,n);
            } else {
                d = refract(d,n,nratio);
                return true;
            }
        }
    }
    return false;
}

vec3 point_light(vec3 p, vec3 d, vec3 n, vec3 p_light, vec3 c_light)  {
    vec3 d_light = p_light-p;
    float dist = length(d_light);
    if (dist > 1e3) return vec3(0.,0.,0.);
    vec3 d_l = d_light/dist;
    vec3 p_l = p;
    float cosa = dot(d_l,n);
    vec3 g;
    if (cosa > 0. && !next_surface(p_l,d_l,g,p_light)) {
        float d_light_n = dot(d_l,n);
        return d_light_n/(dist*dist)*c_light;
    }
    return vec3(0.,0.,0.);
}
    
vec3 light(vec3 p, vec3 d, vec3 n) {
    vec3 color = vec3(0.0,0.0,0.0);
    color += point_light(p,d,n,vec3(2.0,2.5,-2.0),vec3(25.0,0.0,0.0));

    color += point_light(p,d,n,vec3(-2.0,2.5,0.0),vec3(0.0,25.0,0.0));

    color += point_light(p,d,n,vec3(2.0,2.5,2.0),vec3(0.0,0.0,25.0));
    return color+0.03;
}
        
vec3 cast_ray_bt(vec3 p, vec3 d) {
    float prescale = 1.0;
    vec3 color = vec3(0.0,0.0,0.0);
    float atten = 1.0;
    vec3 p_stack[25];
    vec3 d_stack[25];
    float prescale_stack[25];
    int sp = 0;
    for (int i = 0; i < 2500; i++) {
        vec3 g;
        bool hit = next_surface(p,d,g);
        if (hit) {
            Property s = prop(p,d);
            vec3 n = normalize(g);
            bool keep_going = false;
            
            color += prescale*s.emittance;
            
            if (s.transmit > 0.0) {
                float n1 = 1.0;
                float n2 = s.refractive_index;
                vec3 ref_p = p;
                vec3 ref_d = d; 
                vec3 ref_n = n;
                bool exited = resolve_transmission(n1,n2,ref_p,ref_d,ref_n);
                if (exited) {
                    Property ref_s = prop(ref_p,ref_d);
                    color += s.transmit*prescale*ref_s.diffuse*light(ref_p,ref_d,ref_n)*ref_s.color;
                    if (sp < 25) {
                        #define _PUSH(i) if (sp == i) {\
                            p_stack[i] = ref_p;\
                            d_stack[i] = ref_d;\
                            prescale_stack[i] = prescale*s.transmit;\
                        }
                        #define PUSH(i) else _PUSH(i)
                       _PUSH(0)
                        PUSH(1)
                        PUSH(2)
                        PUSH(3)
                        PUSH(4)
                        PUSH(5)
                        PUSH(6)
                        PUSH(7)
                        PUSH(8)
                        PUSH(9)
                        PUSH(10)
                        PUSH(11)
                        PUSH(12)
                        PUSH(13)
                        PUSH(14)
                        PUSH(15)
                        PUSH(16)
                        PUSH(17)
                        PUSH(18)
                        PUSH(19)
                        PUSH(20)
                        PUSH(21)
                        PUSH(22)
                        PUSH(23)
                        PUSH(24)
                        sp++;
                    }
                }
            }

            if (s.diffuse > 0.0) {
                color += prescale*s.diffuse*light(p,d,n)*s.color;
            }

            if (s.specular > 0.0) {
                prescale = prescale*s.specular;
                d = reflect(d,n);
                keep_going = true;
            }
            
            if (keep_going && prescale > 1e-4) continue;
        }
        if (sp > 0) {
            sp--;
            #define _POP(i) if (sp == i) {\
                p = p_stack[i];\
                d = d_stack[i];\
                prescale = prescale_stack[i];\
            }
            #define POP(i) else _POP(i) 
           _POP(0)
            POP(1)  
            POP(2)
            POP(3)
            POP(4)
            POP(5)
            POP(6)
            POP(7)
            POP(8)
            POP(9) 
            POP(10)
            POP(11)  
            POP(12)
            POP(13)
            POP(14)
            POP(15)
            POP(16)
            POP(17)
            POP(18)
            POP(19) 
            POP(20)
            POP(21)  
            POP(22)
            POP(23)
            POP(24)
            continue;
        }
        return color;
    }
}

void main() {
    vec2 st = gl_FragCoord.xy/u_resolution;
    //seed_rand(st);
    float ratio = u_resolution.x/u_resolution.y;
    if (ratio >= 1.0) {
        st.x *= ratio;
        st.x += (1. - ratio)/2.;
    } else {
        st.y /= ratio;
        st.y += (1. - 1./ratio)/2.;
    }
    st = 0.1*(st-0.5)/2.;
    
    float view_dist = 0.1;
    vec3 px_cam = vec3(st.x,st.y,0.1);
    
    /*
    float cost = cos(0.4*cos(u_time));
    float sint = sin(0.4*cos(u_time));
    */
    float cost = cos(u_time);
    float sint = sin(u_time);

    mat3 cam_proj = mat3(cost,0.0,-sint,0.0,1.0,0.0,sint,0.0,cost);
    vec3 cam_orig = vec3(-8.0*sint,0.0,-8.*cost);
    
    vec3 color = vec3(0.0,0.0,0.0);
    const int passes = 1;
    for (int i = 0; i < passes; i++) {
        //color += cast_ray_rt(cam_orig,normalize(cam_proj*px_cam))/float(passes);
        color += cast_ray_bt(cam_orig,normalize(cam_proj*px_cam))/float(passes);
    }
    gl_FragColor = vec4(color,1.0);
}
